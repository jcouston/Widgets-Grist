<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TaskFlow â€” Runtime</title>
    <script src="https://docs.getgrist.com/grist-plugin-api.js"></script>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { font-family: system-ui, -apple-system, sans-serif; min-height: 100vh; display: flex; flex-direction: column; overflow: hidden; background: #f8fafc; }

        /* ===== Loading ===== */
        .loading { flex: 1; display: flex; align-items: center; justify-content: center; flex-direction: column; gap: 12px; }
        .loading.hidden { display: none; }
        .loading-spinner { width: 32px; height: 32px; border: 3px solid #e2e8f0; border-top-color: #4f46e5; border-radius: 50%; animation: spin 0.8s linear infinite; }
        .loading-text { font-size: 13px; color: #64748b; }
        .loading-error { color: #ef4444; }
        @keyframes spin { to { transform: rotate(360deg); } }

        /* ===== App selector (si plusieurs apps) ===== */
        .app-bar { background: #fff; border-bottom: 1px solid #e2e8f0; padding: 8px 16px; display: flex; align-items: center; gap: 12px; flex-shrink: 0; }
        .app-bar.hidden { display: none; }
        .app-bar label { font-size: 12px; color: #64748b; font-weight: 600; }
        .app-bar select { padding: 6px 12px; border: 1px solid #e2e8f0; border-radius: 6px; font-size: 13px; min-width: 220px; }

        /* ===== Runtime layout ===== */
        .runtime { flex: 1; display: none; overflow: hidden; }
        .runtime.active { display: flex; }

        /* Sidebar */
        .sidebar { width: 220px; background: #fff; border-right: 1px solid #e2e8f0; display: flex; flex-direction: column; flex-shrink: 0; transition: width 0.2s; }
        .sidebar.collapsed { width: 56px; }
        .sidebar-header { padding: 16px; border-bottom: 1px solid #e2e8f0; display: flex; align-items: center; gap: 10px; overflow: hidden; }
        .sidebar-logo { width: 36px; height: 36px; border-radius: 10px; display: flex; align-items: center; justify-content: center; font-size: 20px; flex-shrink: 0; }
        .sidebar-title { font-size: 14px; font-weight: 700; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .sidebar.collapsed .sidebar-title { display: none; }

        .sidebar-nav { flex: 1; overflow-y: auto; padding: 8px; }
        .nav-item { padding: 10px 12px; border-radius: 8px; cursor: pointer; display: flex; align-items: center; gap: 10px; font-size: 13px; color: #0f172a; transition: all 0.15s; margin-bottom: 4px; user-select: none; }
        .nav-item:hover { background: #f1f5f9; }
        .nav-item.active { background: var(--theme-primary, #4f46e5); color: #fff; }
        .nav-item-icon { font-size: 18px; flex-shrink: 0; }
        .nav-item-label { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .sidebar.collapsed .nav-item-label { display: none; }

        .sidebar-footer { padding: 8px; border-top: 1px solid #e2e8f0; }
        .sidebar-toggle { width: 100%; padding: 6px; border: 1px solid #e2e8f0; border-radius: 6px; background: #fff; font-size: 11px; cursor: pointer; color: #64748b; }
        .sidebar-toggle:hover { background: #f1f5f9; }

        /* Content */
        .content { flex: 1; display: flex; flex-direction: column; overflow: hidden; }
        .frame { flex: 1; overflow: hidden; position: relative; }
        .frame iframe { width: 100%; height: 100%; border: none; background: #fff; }
    </style>
</head>
<body>

    <!-- Loading -->
    <div class="loading" id="loading">
        <div class="loading-spinner"></div>
        <div class="loading-text" id="loadingText">Connexion Ã  Grist...</div>
    </div>

    <!-- App selector (affichÃ© si plusieurs apps) -->
    <div class="app-bar hidden" id="appBar">
        <label>Application :</label>
        <select id="appSelect" onchange="onAppSelect()"></select>
    </div>

    <!-- Runtime -->
    <div class="runtime" id="runtime">
        <div class="sidebar collapsed" id="sidebar">
            <div class="sidebar-header">
                <div class="sidebar-logo" id="sidebarLogo">ğŸ“‹</div>
                <div class="sidebar-title" id="sidebarTitle">TaskFlow</div>
            </div>
            <nav class="sidebar-nav" id="sidebarNav"></nav>
            <div class="sidebar-footer">
                <button class="sidebar-toggle" id="sidebarToggle" onclick="toggleSidebar()">â–¶</button>
            </div>
        </div>
        <div class="content">
            <div class="frame">
                <iframe id="mainFrame" sandbox="allow-scripts allow-same-origin"></iframe>
            </div>
        </div>
    </div>

<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// STATE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const TABLE_NAME = 'Artefacts';

const state = {
    artefacts: [],
    apps: [],
    currentApp: null,
    currentRoute: '/',
    gristBridge: null,
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// GRIST BRIDGE â€” CÃ´tÃ© parent
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class GristBridgeParent {
    constructor() {
        this.callbackSources = new Map(); // callbackId â†’ source window
        this.nextId = 1;
        window.addEventListener('message', this._handleMessage.bind(this));
    }

    async _handleMessage(event) {
        const data = event.data;
        if (!data || data.type !== 'grist-bridge') return;
        const source = event.source;
        if (!source) return;

        try {
            let result;
            switch (data.action) {
                case 'ready': result = { success: true }; break;
                case 'apiCall': result = await this._handleApiCall(data); break;
                case 'registerCallback': result = await this._handleRegisterCallback(data, source); break;
                default: throw new Error('Unknown bridge action: ' + data.action);
            }
            source.postMessage({ type: 'grist-bridge-response', callId: data.callId, result, error: null }, '*');
        } catch (err) {
            source.postMessage({ type: 'grist-bridge-response', callId: data.callId, result: null, error: err.message }, '*');
        }
    }

    async _handleApiCall(data) {
        const { path, args } = data;
        const parts = path.split('.');
        let target = grist;
        for (let i = 0; i < parts.length - 1; i++) {
            target = target[parts[i]];
            if (!target) throw new Error('Invalid API path: ' + path);
        }
        const method = target[parts[parts.length - 1]];
        if (typeof method !== 'function') throw new Error(path + ' is not a function');
        return await method.apply(target, args || []);
    }

    async _handleRegisterCallback(data, source) {
        const { callbackType } = data;
        const callbackId = 'cb_' + (this.nextId++);
        this.callbackSources.set(callbackId, source);

        if (callbackType === 'onRecords') {
            grist.onRecords((records, mappings) => {
                const src = this.callbackSources.get(callbackId);
                if (src) try { src.postMessage({ type: 'grist-bridge-callback', callbackId, args: [records, mappings] }, '*'); } catch(e) {}
            });
        } else if (callbackType === 'onRecord') {
            grist.onRecord((record, mappings) => {
                const src = this.callbackSources.get(callbackId);
                if (src) try { src.postMessage({ type: 'grist-bridge-callback', callbackId, args: [record, mappings] }, '*'); } catch(e) {}
            });
        } else if (callbackType === 'onOptions') {
            grist.onOptions((options) => {
                const src = this.callbackSources.get(callbackId);
                if (src) try { src.postMessage({ type: 'grist-bridge-callback', callbackId, args: [options] }, '*'); } catch(e) {}
            });
        }

        return { callbackId };
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// GRIST BRIDGE â€” Script injectÃ© cÃ´tÃ© iframe (crÃ©e window.grist)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const GRIST_BRIDGE_SCRIPT = `
(function() {
    const pending = new Map();
    const callbacks = new Map();
    let nextId = 1;

    window.addEventListener('message', function(event) {
        var data = event.data;
        if (data && data.type === 'grist-bridge-response') {
            var p = pending.get(data.callId);
            if (p) {
                pending.delete(data.callId);
                data.error ? p.reject(new Error(data.error)) : p.resolve(data.result);
            }
        }
        if (data && data.type === 'grist-bridge-callback') {
            var cb = callbacks.get(data.callbackId);
            if (cb) cb.apply(null, data.args || []);
        }
    });

    function send(action, payload) {
        return new Promise(function(resolve, reject) {
            var callId = 'call_' + (nextId++);
            pending.set(callId, { resolve: resolve, reject: reject });
            window.parent.postMessage(Object.assign({ type: 'grist-bridge', action: action, callId: callId }, payload), '*');
            setTimeout(function() {
                if (pending.has(callId)) { pending.delete(callId); reject(new Error('Bridge timeout')); }
            }, 30000);
        });
    }

    function registerCallback(type, fn) {
        send('registerCallback', { callbackType: type }).then(function(result) {
            callbacks.set(result.callbackId, fn);
        });
    }

    window.grist = {
        ready: function(options) { return send('ready', { options: options }); },
        docApi: {
            listTables: function() { return send('apiCall', { path: 'docApi.listTables', args: [] }); },
            fetchTable: function(t) { return send('apiCall', { path: 'docApi.fetchTable', args: [t] }); },
            applyUserActions: function(a) { return send('apiCall', { path: 'docApi.applyUserActions', args: [a] }); }
        },
        setSelectedRows: function(rows) { return send('apiCall', { path: 'setSelectedRows', args: [rows] }); },
        onRecords: function(cb) { registerCallback('onRecords', cb); },
        onRecord: function(cb) { registerCallback('onRecord', cb); },
        onOptions: function(cb) { registerCallback('onOptions', cb); }
    };
})();
`;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// APP RUNTIME â€” Script injectÃ© cÃ´tÃ© iframe (crÃ©e window.app)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const APP_RUNTIME_SCRIPT = `
(function() {
    var eventHandlers = new Map();

    window.app = {
        navigate: function(path) {
            window.parent.postMessage({ type: 'app-navigate', path: path }, '*');
        },
        getCurrentRoute: function() { return window.__APP_ROUTE__ || '/'; },

        emit: function(event, data) {
            window.parent.postMessage({ type: 'app-event', event: event, data: data }, '*');
        },
        on: function(event, callback) {
            if (!eventHandlers.has(event)) eventHandlers.set(event, []);
            eventHandlers.get(event).push(callback);
        },

        state: window.__APP_STATE__ || {},
        setState: function(key, value) {
            window.app.state[key] = value;
            window.parent.postMessage({ type: 'app-setState', key: key, value: value }, '*');
        },

        manifest: window.__APP_MANIFEST__ || null,
        isEditMode: false
    };

    window.addEventListener('message', function(event) {
        var data = event.data;
        if (data && data.type === 'app-event-broadcast') {
            var handlers = eventHandlers.get(data.event) || [];
            handlers.forEach(function(h) { h(data.data); });
        }
        if (data && data.type === 'app-state-update') {
            window.app.state[data.key] = data.value;
        }
    });
})();
`;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INJECTION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function injectGristBridge(html) {
    return html.replace(
        /<script\s+src=["']https:\/\/docs\.getgrist\.com\/grist-plugin-api\.js["']\s*><\/script>/gi,
        '<script>' + GRIST_BRIDGE_SCRIPT + '<\/script>'
    );
}

function injectAppRuntime(html, manifest, route) {
    const block = `<script>
window.__APP_MANIFEST__ = ${JSON.stringify(manifest)};
window.__APP_ROUTE__ = ${JSON.stringify(route)};
window.__APP_STATE__ = ${JSON.stringify(state.currentApp?.manifest?.sharedState || {})};
${APP_RUNTIME_SCRIPT}
<\/script>`;

    if (html.includes('</head>')) {
        return html.replace('</head>', block + '\n</head>');
    }
    return block + '\n' + html;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SCHEMA â€” Auto-crÃ©ation de la table Artefacts
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const ARTEFACTS_SCHEMA = {
    columns: [
        { id: 'Nom',          type: 'Text',     label: 'Nom' },
        { id: 'Type',         type: 'Choice',   label: 'Type', widgetOptions: JSON.stringify({ choices: ['app','grist','html','react','component','svg','markdown'] }) },
        { id: 'Code',         type: 'Text',     label: 'Code' },
        { id: 'Description',  type: 'Text',     label: 'Description' },
        { id: 'Dependencies', type: 'Text',     label: 'Dependencies' },
        { id: 'IsDoc',        type: 'Bool',     label: 'IsDoc' },
        { id: 'Icon',         type: 'Text',     label: 'Icon' },
        { id: 'CreatedAt',    type: 'DateTime',  label: 'CreatedAt' },
    ]
};

const DEFAULT_TASKFLOW_MANIFEST = {
    name: 'TaskFlow',
    icon: 'ğŸ“‹',
    theme: { primary: '#4f46e5', accent: '#4338ca' },
    routes: [
        { path: '/',           label: 'Dashboard',  icon: 'ğŸ“Š', artefact: null },
        { path: '/kanban',     label: 'Kanban',     icon: 'ğŸ“‹', artefact: null },
        { path: '/gantt',      label: 'Gantt',      icon: 'ğŸ“ˆ', artefact: null },
        { path: '/calendrier', label: 'Calendrier', icon: 'ğŸ“…', artefact: null },
    ]
};

async function ensureArtefactsTable() {
    // 1. VÃ©rifier si la table existe
    try {
        const data = await grist.docApi.fetchTable(TABLE_NAME);
        // Table existe â€” vÃ©rifier les colonnes manquantes
        const existingCols = Object.keys(data);
        for (const col of ARTEFACTS_SCHEMA.columns) {
            if (!existingCols.includes(col.id)) {
                try {
                    const colDef = { type: col.type, label: col.label };
                    if (col.widgetOptions) colDef.widgetOptions = col.widgetOptions;
                    await grist.docApi.applyUserActions([['AddColumn', TABLE_NAME, col.id, colDef]]);
                } catch { /* colonne existe dÃ©jÃ  ou erreur non bloquante */ }
            }
        }
        return false; // table existait dÃ©jÃ 
    } catch {
        // 2. Table n'existe pas â†’ la crÃ©er
        const colSpecs = ARTEFACTS_SCHEMA.columns.map(c => {
            const spec = { id: c.id, type: c.type, label: c.label };
            if (c.widgetOptions) spec.widgetOptions = c.widgetOptions;
            return spec;
        });
        await grist.docApi.applyUserActions([['AddTable', TABLE_NAME, colSpecs]]);
        return true; // table vient d'Ãªtre crÃ©Ã©e
    }
}

async function seedDefaultApp() {
    const now = Math.floor(Date.now() / 1000);
    await grist.docApi.applyUserActions([
        ['AddRecord', TABLE_NAME, null, {
            Nom: 'TaskFlow',
            Type: 'app',
            Code: JSON.stringify(DEFAULT_TASKFLOW_MANIFEST, null, 2),
            Description: 'Application TaskFlow â€” manifest principal',
            Icon: 'ğŸ“‹',
            CreatedAt: now,
        }]
    ]);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CHARGEMENT DES DONNÃ‰ES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function loadArtefacts() {
    const data = await grist.docApi.fetchTable(TABLE_NAME);
    const items = [];
    const apps = [];
    const n = data.id ? data.id.length : 0;

    for (let i = 0; i < n; i++) {
        const art = {
            id: data.id[i],
            Nom: data.Nom?.[i] || '',
            Type: data.Type?.[i] || '',
            Code: data.Code?.[i] || '',
        };
        items.push(art);
        if (art.Type === 'app') {
            try { art.manifest = JSON.parse(art.Code); } catch { art.manifest = { name: art.Nom, routes: [] }; }
            apps.push(art);
        }
    }

    state.artefacts = items;
    state.apps = apps;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// APP SELECTION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function populateAppSelect() {
    const sel = document.getElementById('appSelect');
    sel.innerHTML = '';
    state.apps.forEach(app => {
        const opt = document.createElement('option');
        opt.value = app.id;
        opt.textContent = (app.manifest?.icon || 'ğŸ“‹') + ' ' + (app.manifest?.name || app.Nom);
        sel.appendChild(opt);
    });
}

function onAppSelect() {
    const id = parseInt(document.getElementById('appSelect').value);
    const app = state.apps.find(a => a.id === id);
    if (app) {
        state.currentApp = app;
        state.currentRoute = '/';
        launchApp(app);
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// RUNTIME â€” Sidebar + Navigation + Rendu
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function launchApp(app) {
    const manifest = app.manifest;
    if (!manifest) return;

    // Appliquer le thÃ¨me
    if (manifest.theme?.primary) {
        document.documentElement.style.setProperty('--theme-primary', manifest.theme.primary);
        document.getElementById('sidebarLogo').style.background =
            `linear-gradient(135deg, ${manifest.theme.primary}, ${manifest.theme.accent || manifest.theme.primary})`;
    }

    // Logo + titre
    document.getElementById('sidebarLogo').textContent = manifest.icon || 'ğŸ“‹';
    document.getElementById('sidebarTitle').textContent = manifest.name || 'TaskFlow';

    // Construire la sidebar
    const nav = document.getElementById('sidebarNav');
    nav.innerHTML = '';
    (manifest.routes || []).forEach(route => {
        const item = document.createElement('div');
        item.className = 'nav-item' + (route.path === state.currentRoute ? ' active' : '');
        item.innerHTML = '<span class="nav-item-icon">' + (route.icon || 'ğŸ“„') + '</span>'
                       + '<span class="nav-item-label">' + (route.label || route.path) + '</span>';
        item.onclick = () => navigateToRoute(route.path);
        nav.appendChild(item);
    });

    // Afficher le runtime
    document.getElementById('loading').classList.add('hidden');
    document.getElementById('runtime').classList.add('active');

    // Charger la route initiale
    navigateToRoute(state.currentRoute);
}

function navigateToRoute(path) {
    state.currentRoute = path;
    const manifest = state.currentApp?.manifest;
    if (!manifest) return;

    // Trouver la route â€” match exact, sinon la route parente
    let route = manifest.routes?.find(r => r.path === path);
    if (!route) {
        const parentPath = '/' + path.split('/').filter(Boolean)[0];
        route = manifest.routes?.find(r => r.path === parentPath);
    }

    // Mettre Ã  jour la sidebar
    document.querySelectorAll('#sidebarNav .nav-item').forEach((item, i) => {
        const routePath = manifest.routes[i]?.path;
        item.classList.toggle('active', routePath === path || (route && routePath === route.path));
    });

    // Charger l'artefact
    if (route?.artefact) {
        const artefact = state.artefacts.find(a => a.id === route.artefact);
        if (artefact) {
            renderArtefact(artefact, path);
        } else {
            renderEmpty('Artefact #' + route.artefact + ' non trouvÃ©');
        }
    } else {
        renderEmpty('Aucun artefact assignÃ© Ã  la route ' + path);
    }
}

function renderArtefact(artefact, route) {
    const iframe = document.getElementById('mainFrame');
    let html = artefact.Code || '';

    // 1. Injecter window.app (navigation, events, state, manifest)
    if (state.currentApp?.manifest) {
        html = injectAppRuntime(html, state.currentApp.manifest, route);
    }

    // 2. Remplacer grist-plugin-api.js par le bridge
    if (html.includes('grist-plugin-api.js')) {
        html = injectGristBridge(html);
    }

    // 3. Charger
    iframe.srcdoc = html;
}

function renderEmpty(msg) {
    const iframe = document.getElementById('mainFrame');
    iframe.srcdoc = '<!DOCTYPE html><html><head><style>body{font-family:system-ui,sans-serif;display:flex;align-items:center;justify-content:center;min-height:100vh;margin:0;color:#64748b;}</style></head><body><div style="text-align:center"><div style="font-size:48px;margin-bottom:12px">ğŸ“„</div><p>' + msg + '</p></div></body></html>';
}

function toggleSidebar() {
    const sidebar = document.getElementById('sidebar');
    sidebar.classList.toggle('collapsed');
    document.getElementById('sidebarToggle').textContent =
        sidebar.classList.contains('collapsed') ? 'â–¶' : 'â—€ RÃ©duire';
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MESSAGES DES IFRAMES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function onMessage(e) {
    const d = e.data;
    if (!d || !d.type) return;

    // Navigation demandÃ©e par un template
    if (d.type === 'app-navigate') {
        navigateToRoute(d.path);
    }

    // Ã‰vÃ©nement inter-widgets
    if (d.type === 'app-event') {
        const iframe = document.getElementById('mainFrame');
        if (iframe?.contentWindow) {
            iframe.contentWindow.postMessage({ type: 'app-event-broadcast', event: d.event, data: d.data }, '*');
        }
    }

    // Mise Ã  jour d'Ã©tat partagÃ©
    if (d.type === 'app-setState') {
        if (state.currentApp?.manifest?.sharedState) {
            state.currentApp.manifest.sharedState[d.key] = d.value;
        }
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INITIALISATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function init() {
    const loadingText = document.getElementById('loadingText');

    try {
        // 1. Bridge
        state.gristBridge = new GristBridgeParent();
        window.addEventListener('message', onMessage);

        // 2. Grist
        grist.ready({ requiredAccess: 'full' });

        // 3. S'assurer que la table Artefacts existe
        loadingText.textContent = 'VÃ©rification de la table Artefacts...';
        const tableCreated = await ensureArtefactsTable();

        // 4. Si table vient d'Ãªtre crÃ©Ã©e, injecter le manifest par dÃ©faut
        if (tableCreated) {
            loadingText.textContent = 'Initialisation de TaskFlow...';
            await seedDefaultApp();
        }

        // 5. Charger les artefacts
        loadingText.textContent = 'Chargement des artefacts...';
        await loadArtefacts();

        if (state.apps.length === 0) {
            loadingText.textContent = 'Aucune application trouvÃ©e dans la table Artefacts';
            loadingText.classList.add('loading-error');
            return;
        }

        // 6. Si plusieurs apps, afficher le sÃ©lecteur
        if (state.apps.length > 1) {
            document.getElementById('appBar').classList.remove('hidden');
            populateAppSelect();
        }

        // 7. Lancer la premiÃ¨re app
        state.currentApp = state.apps[0];
        launchApp(state.currentApp);

    } catch (e) {
        console.error('Init error:', e);
        loadingText.textContent = 'Erreur : ' + e.message;
        loadingText.classList.add('loading-error');
    }
}

init();
</script>
</body>
</html>
